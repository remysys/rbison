%{
#include <hash.h>
#include <set.h>

#define CREATING_LALR_PARSER /* suppress various definitions in parser.h that conflict with rbison-generated defs */
#include "parser.h"

/*
 * this file is a rbison input file that creates a parser for rbison, like a snake
 * eating its tail. the resulting yyparse.c file can be used in place of the
 * recursive-descent parser in llparser.c. note that, though this file is certainly
 * easier to write than the recursive-descent version, the resulting code is
 * about 1k larger. nows() should be called before firing up the parser.
 * most of the external subroutines called from this module are in acts.c.
 * exceptions are:
 */
extern char *yytext; /* generated by rlex */
extern int yylineno; /* generated by rlex */
extern void nows(void); /* declared in parser.l */
extern void ws(void); /* declared in parser.l */

#define YYSTYPE char * /* value-stack type */ 

%}

%token ACTION         /* {str} */
%token CODE_BLOCK     /* %{ ... %} */
%token COLON          /* : */
%token FIELD          /* <name> */
%token LEFT           /* %left */
%token NAME           /* name */
%token NONASSOC       /* %nonassoc */
%token OR             /* | */
%token OTHER          /* anything else (used only in yypar.c) */
%token PREC           /* %prec */
%token RIGHT          /* %right */
%token SEMI           /* ; */
%token SEPARATOR      /* %% */
%token TERM_SPEC      /* %term or %token */
%token TYPE           /* %type */
%token PERCENT_UNION  /* %union */
%token WHITESPACE     /* 0 <= c <= ' ' (used only in yypar.c) */

%%
spec : defs SEPARATOR { first_sym(); } rules end
    ;

end : { ws(); } SEPARATOR
    |   /* empty */
    ;
defs : PERCENT_UNION ACTION         { union_def(yytext); } defs
    | TYPE                        fname { new_field(""); } defs
    | TERM_SPEC  { new_lev(0); } tnames { new_field(""); } defs
    | LEFT     { new_lev('l'); } pnames { new_field(""); } defs
    | RIGHT    { new_lev('r'); } pnames { new_field(""); } defs
    | NONASSOC { new_lev('n'); } pnames { new_field(""); } defs
    | CODE_BLOCK    /* the block is copied out by yylex */ defs
    | /* empty */
    ;

fnames : NAME { new_nonterm(yytext, 0); } fnames
    | FIELD { new_field(yytext); } fnames
    | /* empty */
    ;

tnames : NAME { make_term(yytext); } tnames
    | FIELD { new_field(yytext); } tnames
    | /* empty */
    ;

pnames : NAME { prec_list(yytext); } pnames
    | FIELD { new_field(yytext); } pnames
    | /* empty */
    ;
 
rules : rule rules
    | /* empty */
    ;

rule : NAME { new_nonterm(yytext, 1); } COLON right_sides
    | FIELD { new_nonterm(yytext, 1); } COLON right_sides
    ;

right_sides : { new_rhs(); } rhs end_rhs
    ;

rhs : NAME { add_to_rhs(yytext, 0); } rhs
    | FIELD { add_to_rhs(yytext, 0); } rhs
    | ACTION { add_to_rhs(yytext, start_action()); } rhs
    | PREC NAME { prec(yytext); } rhs
    | /* empty */
    ;

end_rhs : OR right_sides
    | SEMI
    ;
%%